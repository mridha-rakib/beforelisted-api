// file: src/modules/renter/renter.service.ts

import { ROLES } from "@/constants/app.constants";
import { env } from "@/env";
import { logger } from "@/middlewares/pino-logger";
import {
  BadRequestException,
  ConflictException,
  NotFoundException,
} from "@/utils/app-error.utils";
import { generateRandomPassword, hashPassword } from "@/utils/password.utils";
import { Types } from "mongoose";
import { AuthUtil } from "../auth/auth.utils";
import { ReferralService } from "../referral/referral.service";
import type { IUser } from "../user/user.interface";
import { UserService } from "../user/user.service";
import type { IRenterProfile } from "./renter.interface";
import { RenterProfileRepository } from "./renter.repository";
import type {
  CreateRenterProfilePayload,
  RenterProfileResponse,
  RenterRegisterPayload,
  RenterRegistrationResponse,
  RenterStatsResponse,
  UpdateRenterNotificationsPayload,
} from "./renter.type";

/**
 * Renter Service
 * Handles ALL renter-related business logic including registration
 * Follows Single Responsibility Principle
 */
export class RenterService {
  private repository: RenterProfileRepository;
  private userService: UserService;
  private referralService: ReferralService;

  constructor() {
    this.repository = new RenterProfileRepository();
    this.userService = new UserService();
    this.referralService = new ReferralService();
  }

  // ============================================
  // RENTER REGISTRATION (Complete Flow)
  // ============================================

  /**
   * Complete renter registration
   * Handles 3 flows:
   * 1. Normal registration (with password)
   * 2. Admin referral (auto-generated password)
   * 3. Agent referral (with password)
   */
  async registerRenter(
    payload: RenterRegisterPayload
  ): Promise<RenterRegistrationResponse> {
    // 1. Check if email already exists
    const existingUser = await this.userService.getUserByEmail(payload.email);
    if (existingUser) {
      throw new ConflictException("Email already registered");
    }

    // 2. Determine registration flow
    let referrer: IUser | null = null;
    let isAdminReferral = false;
    let isAgentReferral = false;

    if (payload.referralCode) {
      // Validate referral code
      referrer = await this.referralService.validateReferralCode(
        payload.referralCode
      );
      isAdminReferral = referrer.role === ROLES.ADMIN;
      isAgentReferral = referrer.role === ROLES.AGENT;
    }

    // 3. Handle password based on registration flow
    let finalPassword: string;
    let passwordWasAutoGenerated = false;

    if (isAdminReferral) {
      // FLOW 2: Admin referral - Auto-generate password
      finalPassword = generateRandomPassword(12);
      passwordWasAutoGenerated = true;
    } else if (payload.password) {
      // FLOW 1 & 3: Normal or Agent referral - Use provided password
      finalPassword = payload.password;
    } else {
      throw new BadRequestException("Password is required");
    }

    // 4. Hash password
    const hashedPassword = await hashPassword(finalPassword);

    // 5. Create user account
    const user = await this.userService.create({
      email: payload.email,
      password: hashedPassword,
      fullName: payload.fullName,
      phoneNumber: payload.phoneNumber,
      phone: payload.phoneNumber,
      role: ROLES.RENTER,
      emailVerified: false,
      accountStatus: "pending",

      // Referral tracking
      referredBy: referrer?._id,
      referredByRole: referrer?.role as ROLES.ADMIN | ROLES.AGENT | undefined,
      passwordAutoGenerated: passwordWasAutoGenerated,
      mustChangePassword: passwordWasAutoGenerated, // Force password change for auto-generated
    });

    // 6. If user was referred, increment referrer's count
    if (referrer) {
      await this.referralService.recordReferral(referrer._id.toString());
    }

    // 7. Create renter profile
    const profile = await this.repository.create({
      userId: user._id,
      savedRequestsAlerts: true,
      emailNotificationsSubscribed: true,
      matchNotifications: true,
      weeklyReportDigest: false,
      totalPreMarketRequests: 0,
      activePreMarketRequests: 0,
      totalMatches: 0,
      approvedMatches: 0,
      profileCompleteness: 0,
      referrerName: referrer?.fullName,
      referrerEmail: referrer?.email,
      acknowledgedAutoPassword: !passwordWasAutoGenerated, // True if user set password
    });

    // 8. Generate email verification token
    const verificationToken = AuthUtil.generateEmailVerificationToken();
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24);

    await this.userService.updateVerificationToken(user._id.toString(), {
      emailVerificationToken: verificationToken,
      emailVerificationExpiresAt: expiresAt,
    });

    // 9. Send appropriate email based on registration flow
    const verificationLink = AuthUtil.generateVerificationLink(
      env.CLIENT_URL,
      verificationToken
    );

    if (passwordWasAutoGenerated) {
      // Admin referral: Send email with auto-generated password
      // await emailService.sendWelcomeWithPassword(
      //   payload.email,
      //   payload.fullName,
      //   finalPassword,
      //   verificationLink
      // );

      logger.info(
        "Email with auto-generated password sending is currently disabled"
      );
    } else {
      // Normal or agent referral: Send standard verification email
      // await emailService.sendEmailVerification(
      //   payload.email,
      //   payload.fullName,
      //   verificationLink
      // );
      logger.info(
        "Email with auto-generated password sending is currently disabled"
      );
    }

    // 10. Generate JWT tokens
    const tokens = this.generateTokens(
      user._id.toString(),
      user.email,
      user.role
    );

    logger.info(
      {
        userId: user._id,
        registrationType: isAdminReferral
          ? "admin-referral"
          : isAgentReferral
            ? "agent-referral"
            : "normal",
      },
      "Renter registered successfully"
    );

    return {
      user: {
        _id: user._id.toString(),
        email: user.email,
        fullName: user.fullName,
        role: user.role,
        referredBy: referrer?._id.toString(),
        referredByRole: referrer?.role,
        passwordAutoGenerated: passwordWasAutoGenerated,
        mustChangePassword: passwordWasAutoGenerated,
      },
      profile: this.toResponse(profile),
      tokens,
      passwordAutoGenerated: passwordWasAutoGenerated,
    };
  }

  // ============================================
  // RENTER PROFILE OPERATIONS
  // ============================================

  /**
   * Create renter profile (INTERNAL - called after user exists)
   */
  async createRenterProfile(
    userId: string | Types.ObjectId,
    payload?: CreateRenterProfilePayload
  ): Promise<RenterProfileResponse> {
    const profile = await this.repository.create({
      userId,
      savedRequestsAlerts: true,
      emailNotificationsSubscribed: true,
      matchNotifications: true,
      weeklyReportDigest: false,
      totalPreMarketRequests: 0,
      activePreMarketRequests: 0,
      totalMatches: 0,
      approvedMatches: 0,
      profileCompleteness: 0,
      referrerName: payload?.referrerName,
      referrerEmail: payload?.referrerEmail,
      acknowledgedAutoPassword: payload?.acknowledgedAutoPassword ?? false,
    });

    logger.info({ userId }, "Renter profile created");
    return this.toResponse(profile);
  }

  /**
   * Get renter profile
   */
  async getRenterProfile(userId: string): Promise<RenterProfileResponse> {
    const profile = await this.repository.findByUserId(userId);
    if (!profile) {
      throw new NotFoundException("Renter profile not found");
    }

    return this.toResponse(profile);
  }

  /**
   * Update notification preferences
   */
  async updateNotificationPreferences(
    userId: string,
    payload: UpdateRenterNotificationsPayload
  ): Promise<RenterProfileResponse> {
    const profile = await this.repository.findByUserId(userId);
    if (!profile) {
      throw new NotFoundException("Renter profile not found");
    }

    const updated = await this.repository.updateNotificationPreferences(
      userId,
      payload
    );

    if (!updated) {
      throw new NotFoundException("Renter profile not found");
    }

    logger.info({ userId }, "Notification preferences updated");
    return this.toResponse(updated);
  }

  /**
   * Unsubscribe from email notifications
   */
  async unsubscribeFromEmail(userId: string): Promise<RenterProfileResponse> {
    const profile = await this.repository.findByUserId(userId);
    if (!profile) {
      throw new NotFoundException("Renter profile not found");
    }

    const updated = await this.repository.unsubscribeEmail(userId);
    if (!updated) {
      throw new NotFoundException("Renter profile not found");
    }

    logger.info({ userId }, "Unsubscribed from email notifications");
    return this.toResponse(updated);
  }

  /**
   * Acknowledge auto-generated password
   */
  async acknowledgeAutoPassword(
    userId: string
  ): Promise<RenterProfileResponse> {
    const profile = await this.repository.findByUserId(userId);
    if (!profile) {
      throw new NotFoundException("Renter profile not found");
    }

    const updated = await this.repository.updateByUserId(userId, {
      acknowledgedAutoPassword: true,
    });

    if (!updated) {
      throw new NotFoundException("Renter profile not found");
    }

    logger.info({ userId }, "Auto-generated password acknowledged");
    return this.toResponse(updated);
  }

  /**
   * Get renter statistics
   */
  async getRenterStats(userId: string): Promise<RenterStatsResponse> {
    const profile = await this.repository.findByUserId(userId);
    if (!profile) {
      throw new NotFoundException("Renter profile not found");
    }

    return {
      totalPreMarketRequests: profile.totalPreMarketRequests,
      activePreMarketRequests: profile.activePreMarketRequests,
      totalMatches: profile.totalMatches,
      approvedMatches: profile.approvedMatches,
      profileCompleteness: profile.profileCompleteness,
    };
  }

  // ============================================
  // INTERNAL HELPER METHODS
  // ============================================

  async incrementPreMarketRequests(userId: string): Promise<void> {
    await this.repository.incrementPreMarketRequests(userId);
  }

  async decrementActivePreMarketRequests(userId: string): Promise<void> {
    await this.repository.decrementActivePreMarketRequests(userId);
  }

  async incrementTotalMatches(userId: string): Promise<void> {
    await this.repository.incrementTotalMatches(userId);
  }

  async incrementApprovedMatches(userId: string): Promise<void> {
    await this.repository.incrementApprovedMatches(userId);
  }

  async getProfileById(userId: string): Promise<IRenterProfile | null> {
    return this.repository.findByUserId(userId);
  }

  // ============================================
  // ADMIN OPERATIONS
  // ============================================

  async adminGetAllRenters(): Promise<RenterProfileResponse[]> {
    const renters: IRenterProfile[] = await this.repository.find({});
    return renters.map((renter: IRenterProfile) => this.toResponse(renter));
  }

  async adminGetRenter(userId: string): Promise<RenterProfileResponse> {
    const profile = await this.repository.findByUserId(userId);
    if (!profile) {
      throw new NotFoundException("Renter profile not found");
    }

    return this.toResponse(profile);
  }

  // ============================================
  // PRIVATE METHODS
  // ============================================

  /**
   * Generate JWT tokens
   */
  private generateTokens(
    userId: string,
    email: string,
    role: string
  ): {
    accessToken: string;
    refreshToken: string;
    expiresIn: string;
  } {
    const accessToken = AuthUtil.generateAccessToken({
      userId,
      email,
      role,
    });

    const refreshToken = AuthUtil.generateRefreshToken(userId);

    return {
      accessToken,
      refreshToken,
      expiresIn: "7d",
    };
  }

  /**
   * Convert to response
   */
  private toResponse(profile: IRenterProfile): RenterProfileResponse {
    return {
      _id: profile._id.toString(),
      userId: profile.userId.toString(),
      savedRequestsAlerts: profile.savedRequestsAlerts,
      emailNotificationsSubscribed: profile.emailNotificationsSubscribed,
      matchNotifications: profile.matchNotifications,
      weeklyReportDigest: profile.weeklyReportDigest,
      totalPreMarketRequests: profile.totalPreMarketRequests,
      activePreMarketRequests: profile.activePreMarketRequests,
      totalMatches: profile.totalMatches,
      approvedMatches: profile.approvedMatches,
      profileCompleteness: profile.profileCompleteness,
      referrerName: profile.referrerName,
      referrerEmail: profile.referrerEmail,
      acknowledgedAutoPassword: profile.acknowledgedAutoPassword,
      createdAt: profile.createdAt,
      updatedAt: profile.updatedAt,
    };
  }
}
