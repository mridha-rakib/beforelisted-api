// file: src/modules/user/user.service.ts (ENHANCED VERSION)

import {
  MESSAGES,
  ROLES,
  SYSTEM_DEFAULT_ADMIN,
  SYSTEM_DEFAULT_AGENT,
} from "@/constants/app.constants";
import { logger } from "@/middlewares/pino-logger";
import { EmailService } from "@/services/email.service";
import {
  ForbiddenException,
  NotFoundException,
} from "@/utils/app-error.utils";
import { ReferralService } from "../referral/referral.service";
import type { IUser } from "./user.interface";
import { PreMarketService } from "../pre-market/pre-market.service";
import { UserRepository } from "./user.repository";
import type {
  UpdateUserPayload,
  UserCreatePayload,
  UserResponse,
} from "./user.type";

export class UserService {
  private userRepository: UserRepository;
  private referralService: ReferralService;
  private emailService: EmailService;
  private preMarketService: PreMarketService;

  constructor() {
    this.userRepository = new UserRepository();
    this.emailService = new EmailService();
    this.referralService = new ReferralService();
    this.preMarketService = new PreMarketService();
  }

  toUserResponse(user: IUser): UserResponse {
    const referredByValue = user.referredBy;
    const referredBy =
      referredByValue &&
      typeof referredByValue === "object" &&
      "_id" in referredByValue
        ? String(referredByValue._id)
        : referredByValue
        ? String(referredByValue)
        : undefined;

    const deletedByValue = user.deletedBy;
    const deletedBy =
      deletedByValue &&
      typeof deletedByValue === "object" &&
      "_id" in deletedByValue
        ? String(deletedByValue._id)
        : deletedByValue
        ? String(deletedByValue)
        : undefined;

    return {
      _id: user._id.toString(),
      email: user.email,
      fullName: user.fullName,
      phone: user.phoneNumber || "",
      phoneNumber: user.phoneNumber || undefined,
      role: user.role,
      accountStatus: user.accountStatus,
      emailVerified: user.emailVerified,
      lastLoginAt: user.lastLoginAt,
      profileImage: user.profileImageUrl || undefined,
      profileImageUrl: user.profileImageUrl ?? null,

      // Referral fields
      referralCode: user.referralCode || undefined,
      referralLink: user.referralLink || null,
      loginLink: user.loginLink || null,
      referredBy,
      referredByRole: user.referredByRole,
      firstReferralUsedAt: user.firstReferralUsedAt,
      totalReferrals: user.totalReferrals || 0,
      passwordAutoGenerated: user.passwordAutoGenerated || false,
      mustChangePassword: user.mustChangePassword || false,
      canRefer: user.canRefer ?? false,

      passwordChangedAt: user.passwordChangedAt,
      isDeleted: user.isDeleted,
      deletedAt: user.deletedAt,
      deletedBy,

      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    };
  }

  /**
   * Alias for consistency (if needed elsewhere)
   */
  getUserResponse(user: IUser): UserResponse {
    return this.toUserResponse(user);
  }

  /**
   * Create new user
   */
  async create(payload: UserCreatePayload): Promise<IUser> {
    try {
      const user = await this.userRepository.create(payload);
      logger.info({ userId: user._id, email: user.email }, "User created");
      return user;
    } catch (error) {
      logger.error(error, "Error creating user");
      throw error;
    }
  }

  /**
   * Get user by ID
   */
  async getUserById(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }
    return this.toUserResponse(user);
  }

  /**
   * Get user by ID (returns full IUser document)
   */
  async getById(userId: string): Promise<IUser | null> {
    return this.userRepository.findById(userId);
  }

  /**
   * Get user by email
   */
  async getUserByEmail(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmail(email);
  }

  /**
   * Get user by email with password (for authentication)
   */
  async getUserByEmailWithPassword(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmailWithPassword(email);
  }

  /**
   * Get user by verification token
   */
  async getUserByVerificationToken(token: string): Promise<IUser | null> {
    return this.userRepository.findByVerificationToken(token);
  }

  /**
   * Get user profile with populated referrer
   */
  async getUserProfile(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    // Optionally populate referredBy
    if (user.referredBy) {
      await user.populate({
        path: "referredBy",
        select: "fullName email role referralCode",
      });
    }

    return this.toUserResponse(user);
  }

  /**
   * Update user profile
   * Also syncs fullName and phoneNumber to role-specific profile (Renter/Agent)
   */
  async updateUserProfile(
    userId: string,
    payload: UpdateUserPayload
  ): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    const updatedUser = await this.userRepository.updateById(userId, payload);
    if (!updatedUser) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    // Sync fullName and phoneNumber to role-specific profile
    const syncPayload: Record<string, any> = {};
    if (payload.fullName) syncPayload.fullName = payload.fullName;
    if (payload.phoneNumber) syncPayload.phoneNumber = payload.phoneNumber;

    if (Object.keys(syncPayload).length > 0) {
      if (user.role === "Renter") {
        // Sync to Renter profile
        const { RenterRepository } = await import("../renter/renter.repository");
        const renterRepository = new RenterRepository();
        await renterRepository.updateByUserId(userId, syncPayload);
        logger.info({ userId, role: "Renter" }, "Profile synced to Renter model");
      } else if (user.role === "Agent") {
        // Sync to Agent profile
        const { AgentProfileRepository } = await import("../agent/agent.repository");
        const agentRepository = new AgentProfileRepository();
        await agentRepository.updateByUserId(userId, syncPayload);
        logger.info({ userId, role: "Agent" }, "Profile synced to Agent model");
      }
    }

    logger.info({ userId }, "User profile updated");
    return this.toUserResponse(updatedUser);
  }

  /**
   * Delete user account (hard delete)
   */
  async deleteUserAccount(userId: string): Promise<{ message: string }> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }
    this.assertSystemUserDeletable(user);

    if (user.role === ROLES.RENTER) {
      await this.preMarketService.deleteRequestsByRenterId(userId);
    }

    await this.userRepository.permanentlyDeleteUser(userId);

    return { message: MESSAGES.USER.USER_DELETED };
  }

  // ============================================
  // VERIFICATION & AUTH HELPERS
  // ============================================

  /**
   * Mark email as verified
   */
  async markEmailAsVerified(userId: string): Promise<IUser | null> {
    return this.userRepository.markEmailAsVerified(userId);
  }

  /**
   * Update verification token
   */
  async updateVerificationToken(
    userId: string,
    data: {
      emailVerificationToken?: string;
      emailVerificationExpiresAt?: Date;
    }
  ): Promise<IUser | null> {
    return this.userRepository.updateVerificationToken(userId, data);
  }

  /**
   * Update password
   */
  async updatePassword(
    userId: string,
    hashedPassword: string
  ): Promise<IUser | null> {
    return this.userRepository.updatePassword(userId, hashedPassword);
  }

  /**
   * Update last login timestamp
   */
  async updateLastLogin(userId: string): Promise<IUser | null> {
    return this.userRepository.updateLastLogin(userId);
  }

  // ============================================
  // ADMIN OPERATIONS
  // ============================================

  /**
   * ADMIN: Get user by ID
   */
  async adminGetUser(userId: string): Promise<UserResponse> {
    return this.getUserById(userId);
  }

  /**
   * ADMIN: Restore soft-deleted user
   */
  async adminRestoreUser(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.restoreUser(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    logger.info({ userId }, "User restored by admin");
    return this.toUserResponse(user);
  }

  /**
   * ADMIN: Permanently delete user
   */
  async adminPermanentlyDeleteUser(
    userId: string
  ): Promise<{ message: string }> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }
    this.assertSystemUserDeletable(user);

    let referredRenters: any[] = [];
    if (user.role === ROLES.AGENT) {
      const { RenterRepository } = await import("../renter/renter.repository");
      const renterRepository = new RenterRepository();
      referredRenters = await renterRepository.findRentersByAgent(userId);
    }

    await this.userRepository.permanentlyDeleteUser(userId);

    if (user.role === ROLES.AGENT && referredRenters.length > 0) {
      await Promise.all(
        referredRenters.map(async (renter: any) => {
          if (!renter?.email) {
            return;
          }

          try {
            const emailResult =
              await this.emailService.sendRegisteredAgentNoLongerActiveToRenter(
                {
                  to: renter.email,
                  renterName: renter.fullName || "Renter",
                  notificationReason: "deleted",
                },
              );

            if (!emailResult.success) {
              logger.warn(
                {
                  userId,
                  renterEmail: renter.email,
                  error: emailResult.error,
                },
                "Registered-agent-inactive email failed to send",
              );
            }
          } catch (error) {
            logger.error(
              {
                userId,
                renterEmail: renter.email,
                error: error instanceof Error ? error.message : String(error),
              },
              "Error sending registered-agent-inactive email",
            );
          }
        }),
      );
    }

    logger.warn({ userId }, "User permanently deleted by admin");
    return { message: "User permanently deleted" };
  }

  /**
   * Forces user to re-login on all devices after password change.
   * Improves security by requiring fresh authentication after password change.
   *
   * @param userId - User ID
   * @returns Number of tokens invalidated
   */
  async invalidateAllRefreshTokens(userId: string): Promise<number> {
    try {
      // Option 1: If you have RefreshTokenBlacklist collection
      // Delete all refresh tokens for this user
      const result = await this.userRepository.deleteAllRefreshTokens(userId);

      logger.info(
        { userId, tokensDeleted: result },
        "All refresh tokens invalidated for user"
      );

      return result || 0;

      // Option 2: If you use a token management service
      // return await this.tokenService.invalidateAllUserTokens(userId);
    } catch (error) {
      logger.error({ userId, error }, "Error invalidating refresh tokens");
      throw error;
    }
  }

  /**
   * Notify user about password change
   * Sends security alert email with timestamp
   *
   * @param email - User's email
   * @param fullName - User's full name
   * @param changedAt - When password was changed
   */
  async notifyPasswordChange(
    email: string,
    fullName: string,
    changedAt: Date
  ): Promise<void> {
    try {
      await this.emailService.sendPasswordChangedEmail({
        to: email,
        userName: fullName,
        timestamp: changedAt,
      });

      logger.info({ email, changedAt }, "Password change notification sent");
    } catch (error) {
      logger.error(
        { email, error },
        "Failed to send password change notification"
      );
      // Don't throw - email failure shouldn't block password change
    }
  }

  /**
   * Get user by ID WITH password field (for authentication only)
   * âœ… Used for: Password verification during change-password
   * @param userId - User ID
   * @returns Full IUser document with password
   * @throws NotFoundException if user not found
   */
  async getUserByIdWithPassword(userId: string): Promise<IUser> {
    const user = await this.userRepository.findByIdWithPassword(userId);

    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    logger.debug({ userId }, "User retrieved with password field");

    return user;
  }

  async getReferralStats(userId: string): Promise<{
    referralCode: string | null;
    referralLink: string | null;
    loginLink: string | null;
    totalReferrals: number;
    referredUsers: any[];
  }> {
    return this.referralService.getReferralStats(userId);
  }

  async updateAccountStatus(
    userId: string,
    status: "active" | "inactive" | "pending"
  ): Promise<IUser | null> {
    const user = await this.userRepository.updateById(userId, {
      accountStatus: status,
    });

    if (user) {
      logger.info({ userId, newStatus: status }, "User account status updated");
    }

    return user;
  }

  private assertSystemUserDeletable(user: IUser): void {
    const email = (user.email || "").toLowerCase();

    if (email === SYSTEM_DEFAULT_ADMIN.email.toLowerCase()) {
      throw new ForbiddenException("Default admin account cannot be deleted");
    }

    if (email === SYSTEM_DEFAULT_AGENT.email.toLowerCase()) {
      throw new ForbiddenException(
        "Default assigned agent account cannot be deleted"
      );
    }
  }
}
