// file: src/modules/user/user.service.ts (ENHANCED VERSION)

import { MESSAGES } from "@/constants/app.constants";
import { logger } from "@/middlewares/pino-logger";
import { emailService } from "@/services/email.service";
import {
  BadRequestException,
  ConflictException,
  NotFoundException,
  UnauthorizedException,
} from "@/utils/app-error.utils";
import { comparePassword, hashPassword } from "@/utils/password.utils";
import type { IUser } from "./user.interface";
import { UserRepository } from "./user.repository";
import type {
  AdminUpdateUserPayload,
  ChangePasswordPayload,
  UpdateUserPayload,
  UserCreatePayload,
  UserResponse,
} from "./user.type";

/**
 * User Service
 * Handles all user business logic
 */
export class UserService {
  private userRepository: UserRepository;

  constructor() {
    this.userRepository = new UserRepository();
  }

  // ============================================
  // RESPONSE TRANSFORMATION
  // ============================================

  /**
   * Convert IUser document to safe UserResponse (removes sensitive fields)
   * This is the method expected by AuthService
   */
  toUserResponse(user: IUser): UserResponse {
    return {
      _id: user._id.toString(),
      email: user.email,
      fullName: user.fullName,
      phone: user.phone || "", // Handle both field names
      role: user.role,
      accountStatus: user.accountStatus,
      emailVerified: user.emailVerified,
      lastLoginAt: user.lastLoginAt,

      // Referral fields
      referralCode: user.referralCode || undefined,
      referralLink: user.referralLink || null,
      referredBy: user.referredBy?.toString(),
      referredByRole: user.referredByRole,
      totalReferrals: user.totalReferrals || 0,
      passwordAutoGenerated: user.passwordAutoGenerated || false,
      mustChangePassword: user.mustChangePassword || false,

      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    };
  }

  /**
   * Alias for consistency (if needed elsewhere)
   */
  getUserResponse(user: IUser): UserResponse {
    return this.toUserResponse(user);
  }

  // ============================================
  // USER CRUD OPERATIONS
  // ============================================

  /**
   * Create new user
   */
  async create(payload: UserCreatePayload): Promise<IUser> {
    try {
      const user = await this.userRepository.create(payload);
      logger.info({ userId: user._id, email: user.email }, "User created");
      return user;
    } catch (error) {
      logger.error(error, "Error creating user");
      throw error;
    }
  }

  /**
   * Get user by ID
   */
  async getUserById(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }
    return this.toUserResponse(user);
  }

  /**
   * Get user by ID (returns full IUser document)
   */
  async getById(userId: string): Promise<IUser | null> {
    return this.userRepository.findById(userId);
  }

  /**
   * Get user by email
   */
  async getUserByEmail(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmail(email);
  }

  /**
   * Get user by email with password (for authentication)
   */
  async getUserByEmailWithPassword(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmailWithPassword(email);
  }

  /**
   * Get user by verification token
   */
  async getUserByVerificationToken(token: string): Promise<IUser | null> {
    return this.userRepository.findByVerificationToken(token);
  }

  /**
   * Get user profile with populated referrer
   */
  async getUserProfile(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    // Optionally populate referredBy
    if (user.referredBy) {
      await user.populate({
        path: "referredBy",
        select: "fullName email role referralCode",
      });
    }

    return this.toUserResponse(user);
  }

  // ============================================
  // USER UPDATES
  // ============================================

  /**
   * Update user profile
   */
  async updateUserProfile(
    userId: string,
    payload: UpdateUserPayload
  ): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    const updatedUser = await this.userRepository.updateById(userId, payload);
    if (!updatedUser) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    logger.info({ userId }, "User profile updated");
    return this.toUserResponse(updatedUser);
  }

  /**
   * Request email change
   */
  async requestEmailChange(
    userId: string,
    newEmail: string
  ): Promise<{ message: string }> {
    // Check if new email already exists
    const existingUser = await this.getUserByEmail(newEmail);
    if (existingUser) {
      throw new ConflictException("Email already in use");
    }

    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    // Generate verification code
    const verificationCode = Math.floor(
      100000 + Math.random() * 900000
    ).toString();

    // Store code temporarily (you might want to create a separate collection for this)
    // For now, we'll use emailVerificationToken field
    await this.userRepository.updateVerificationToken(userId, {
      emailVerificationToken: verificationCode,
      emailVerificationExpiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes
    });

    // Send verification email to new address
    await emailService.sendEmailVerification(
      newEmail,
      user.fullName,
      verificationCode
    );

    return { message: "Verification code sent to new email" };
  }

  /**
   * Verify new email
   */
  async verifyNewEmail(
    userId: string,
    newEmail: string,
    verificationCode: string
  ): Promise<{ message: string }> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    // Verify code
    if (
      user.emailVerificationToken !== verificationCode ||
      !user.emailVerificationExpiresAt ||
      user.emailVerificationExpiresAt < new Date()
    ) {
      throw new BadRequestException("Invalid or expired verification code");
    }

    // Update email
    await this.userRepository.updateById(userId, {
      email: newEmail,
      emailVerificationToken: undefined,
      emailVerificationExpiresAt: undefined,
    });

    logger.info({ userId, newEmail }, "Email changed successfully");
    return { message: "Email updated successfully" };
  }

  /**
   * Change password
   */
  async changePassword(
    userId: string,
    payload: ChangePasswordPayload
  ): Promise<{ message: string }> {
    const user = await this.userRepository.findByIdWithPassword(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    // Verify current password
    if (!user.password) {
      throw new BadRequestException("No password set for this account");
    }

    const isPasswordValid = await comparePassword(
      payload.currentPassword,
      user.password
    );

    if (!isPasswordValid) {
      throw new UnauthorizedException("Current password is incorrect");
    }

    // Hash new password
    const hashedPassword = await hashPassword(payload.newPassword);

    // Update password
    await this.userRepository.updatePassword(userId, hashedPassword);

    logger.info({ userId }, "Password changed successfully");
    return { message: MESSAGES.USER.PASSWORD_CHANGED };
  }

  /**
   * Delete user account (soft delete)
   */
  async deleteUserAccount(userId: string): Promise<{ message: string }> {
    const user = await this.userRepository.softDeleteUser(userId, userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    logger.info({ userId }, "User account deleted (soft delete)");
    return { message: MESSAGES.USER.USER_DELETED };
  }

  // ============================================
  // VERIFICATION & AUTH HELPERS
  // ============================================

  /**
   * Mark email as verified
   */
  async markEmailAsVerified(userId: string): Promise<IUser | null> {
    return this.userRepository.markEmailAsVerified(userId);
  }

  /**
   * Update verification token
   */
  async updateVerificationToken(
    userId: string,
    data: {
      emailVerificationToken?: string;
      emailVerificationExpiresAt?: Date;
    }
  ): Promise<IUser | null> {
    return this.userRepository.updateVerificationToken(userId, data);
  }

  /**
   * Update password
   */
  async updatePassword(
    userId: string,
    hashedPassword: string
  ): Promise<IUser | null> {
    return this.userRepository.updatePassword(userId, hashedPassword);
  }

  /**
   * Update last login timestamp
   */
  async updateLastLogin(userId: string): Promise<IUser | null> {
    return this.userRepository.updateLastLogin(userId);
  }

  // ============================================
  // ADMIN OPERATIONS
  // ============================================

  /**
   * ADMIN: Get user by ID
   */
  async adminGetUser(userId: string): Promise<UserResponse> {
    return this.getUserById(userId);
  }

  /**
   * ADMIN: List all users with pagination
   */
  async adminListUsers(
    page: number = 1,
    limit: number = 10,
    search?: string,
    role?: string,
    accountStatus?: string,
    sort: string = "-createdAt"
  ): Promise<{
    data: UserResponse[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    const skip = (page - 1) * limit;

    // Build query
    const query: any = { isDeleted: false };

    if (search) {
      query.$or = [
        { email: { $regex: search, $options: "i" } },
        { fullName: { $regex: search, $options: "i" } },
      ];
    }

    if (role) {
      query.role = role;
    }

    if (accountStatus) {
      query.accountStatus = accountStatus;
    }

    // Get users
    const users = await this.userRepository.find(query, {
      skip,
      limit,
      sort,
    });

    const total = await this.userRepository.count(query);

    return {
      data: users.map((user) => this.toUserResponse(user)),
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * ADMIN: Update user
   */
  async adminUpdateUser(
    userId: string,
    payload: AdminUpdateUserPayload
  ): Promise<UserResponse> {
    const updatedUser = await this.userRepository.updateById(userId, payload);
    if (!updatedUser) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    logger.info({ userId, adminUpdate: true }, "User updated by admin");
    return this.toUserResponse(updatedUser);
  }

  /**
   * ADMIN: Delete user (soft delete)
   */
  async adminDeleteUser(
    userId: string,
    deletedBy: string
  ): Promise<{ message: string }> {
    const user = await this.userRepository.softDeleteUser(userId, deletedBy);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    logger.info({ userId, deletedBy }, "User deleted by admin");
    return { message: MESSAGES.USER.USER_DELETED };
  }

  /**
   * ADMIN: Restore soft-deleted user
   */
  async adminRestoreUser(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.restoreUser(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    logger.info({ userId }, "User restored by admin");
    return this.toUserResponse(user);
  }

  /**
   * ADMIN: Permanently delete user
   */
  async adminPermanentlyDeleteUser(
    userId: string
  ): Promise<{ message: string }> {
    await this.userRepository.permanentlyDeleteUser(userId);

    logger.warn({ userId }, "User permanently deleted by admin");
    return { message: "User permanently deleted" };
  }
}
